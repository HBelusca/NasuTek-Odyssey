Index: build.h
===================================================================
--- build.h	(Revision 4)
+++ build.h	(Arbeitskopie)
@@ -38,6 +38,8 @@
 #define min(a,b)   (((a) < (b)) ? (a) : (b))
 #endif
 
+#define EXEEXT ".exe"
+
 typedef enum
 {
     TYPE_VARIABLE,     /* variable */
@@ -47,6 +49,7 @@
     TYPE_STDCALL,      /* stdcall function (Win32) */
     TYPE_CDECL,        /* cdecl function (Win32) */
     TYPE_VARARGS,      /* varargs function (Win32) */
+    TYPE_FASTCALL,     /* fastcall function (Win32) */
     TYPE_EXTERN,       /* external symbol (Win32) */
     TYPE_NBTYPES
 } ORD_TYPE;
@@ -269,6 +272,7 @@
 extern void BuildSpec16File( DLLSPEC *spec );
 extern void BuildSpec32File( DLLSPEC *spec );
 extern void BuildDef32File( DLLSPEC *spec );
+extern void BuildPedllFile( DLLSPEC *spec );
 
 extern void add_16bit_exports( DLLSPEC *spec32, DLLSPEC *spec16 );
 extern int parse_spec_file( FILE *file, DLLSPEC *spec );
Index: main.c
===================================================================
--- main.c	(Revision 4)
+++ main.c	(Arbeitskopie)
@@ -48,9 +48,9 @@
 int link_ext_symbols = 0;
 int force_pointer_size = 0;
 
-#ifdef __i386__
+#if defined(TARGET_i386)
 enum target_cpu target_cpu = CPU_x86;
-#elif defined(__x86_64__)
+#elif defined(TARGET_amd64)
 enum target_cpu target_cpu = CPU_x86_64;
 #elif defined(__sparc__)
 enum target_cpu target_cpu = CPU_SPARC;
@@ -58,7 +58,7 @@
 enum target_cpu target_cpu = CPU_ALPHA;
 #elif defined(__powerpc__)
 enum target_cpu target_cpu = CPU_POWERPC;
-#elif defined(__arm__)
+#elif defined(TARGET_arm)
 enum target_cpu target_cpu = CPU_ARM;
 #else
 #error Unsupported CPU
@@ -102,7 +102,8 @@
     MODE_DEF,
     MODE_RELAY16,
     MODE_RELAY32,
-    MODE_RESOURCES
+    MODE_RESOURCES,
+    MODE_PEDLL
 };
 
 static enum exec_mode_values exec_mode = MODE_NONE;
@@ -253,6 +254,7 @@
 "       --relay16             Build the 16-bit relay assembly routines\n"
 "       --relay32             Build the 32-bit relay assembly routines\n"
 "       --resources           Build a .o file for the resource files\n\n"
+"       --pedll              Build a .c file for PE dll\n\n"
 "The mode options are mutually exclusive; you must specify one and only one.\n\n";
 
 enum long_options_values
@@ -272,7 +274,8 @@
     LONG_OPT_RESOURCES,
     LONG_OPT_SAVE_TEMPS,
     LONG_OPT_SUBSYSTEM,
-    LONG_OPT_VERSION
+    LONG_OPT_VERSION,
+    LONG_OPT_PEDLL
 };
 
 static const char short_options[] = "C:D:E:F:H:I:K:L:M:N:b:d:e:f:hi:kl:m:o:r:u:vw";
@@ -295,6 +298,7 @@
     { "save-temps",    0, 0, LONG_OPT_SAVE_TEMPS },
     { "subsystem",     1, 0, LONG_OPT_SUBSYSTEM },
     { "version",       0, 0, LONG_OPT_VERSION },
+    { "pedll",         1, 0, LONG_OPT_PEDLL },
     /* aliases for short options */
     { "target",        1, 0, 'b' },
     { "delay-lib",     1, 0, 'd' },
@@ -497,6 +501,11 @@
         case LONG_OPT_VERSION:
             printf( "winebuild version " PACKAGE_VERSION "\n" );
             exit(0);
+        case LONG_OPT_PEDLL:
+            set_exec_mode( MODE_PEDLL );
+            spec_file_name = xstrdup( optarg );
+            set_dll_file_name( optarg, spec );
+            break;
         case '?':
             usage(1);
             break;
@@ -652,6 +661,11 @@
         if (argv[0]) fatal_error( "file argument '%s' not allowed in this mode\n", argv[0] );
         BuildRelays32();
         break;
+    case MODE_PEDLL:
+        if (argv[0]) fatal_error( "file argument '%s' not allowed in this mode\n", argv[0] );
+        if (!parse_input_file( spec )) break;
+        BuildPedllFile( spec );
+        break;
     case MODE_RESOURCES:
         load_resources( argv, spec );
         output_res_o_file( spec );
Index: parser.c
===================================================================
--- parser.c	(Revision 4)
+++ parser.c	(Arbeitskopie)
@@ -56,6 +56,7 @@
     "stdcall",      /* TYPE_STDCALL */
     "cdecl",        /* TYPE_CDECL */
     "varargs",      /* TYPE_VARARGS */
+    "fastcall",     /* TYPE_FASTCALL */
     "extern"        /* TYPE_EXTERN */
 };
 
@@ -521,6 +522,7 @@
     case TYPE_STDCALL:
     case TYPE_VARARGS:
     case TYPE_CDECL:
+    case TYPE_FASTCALL:
         if (!parse_spec_export( odp, spec )) goto error;
         break;
     case TYPE_ABS:
Index: res32.c
===================================================================
--- res32.c	(Revision 4)
+++ res32.c	(Arbeitskopie)
@@ -35,12 +35,14 @@
 #include "build.h"
 
 typedef unsigned short WCHAR;
+typedef unsigned short WORD;
+typedef unsigned int DWORD;
 
 /* Unicode string or integer id */
 struct string_id
 {
     WCHAR *str;  /* ptr to Unicode string */
-    unsigned short id;   /* integer id if str is NULL */
+    WORD   id;   /* integer id if str is NULL */
 };
 
 /* descriptor for a resource */
@@ -195,7 +197,7 @@
 /* all values must be zero except header size */
 static int check_header(void)
 {
-    unsigned int size;
+    DWORD size;
 
     if (get_dword()) return 0;        /* data size */
     size = get_dword();               /* header size */
@@ -214,14 +216,14 @@
 /* load the next resource from the current file */
 static void load_next_resource( DLLSPEC *spec )
 {
-    unsigned int hdr_size;
+    DWORD hdr_size;
     struct resource *res = add_resource( spec );
 
     res->data_size = get_dword();
     hdr_size = get_dword();
     if (hdr_size & 3) fatal_error( "%s header size not aligned\n", input_buffer_filename );
 
-    res->data = input_buffer + input_buffer_pos - 2*sizeof(unsigned int) + hdr_size;
+    res->data = input_buffer + input_buffer_pos - 2*sizeof(DWORD) + hdr_size;
     get_string( &res->type );
     get_string( &res->name );
     if (input_buffer_pos & 2) get_word();  /* align to dword boundary */
Index: spec32.c
===================================================================
--- spec32.c	(Revision 4)
+++ spec32.c	(Arbeitskopie)
@@ -74,6 +74,28 @@
 }
 
 /*******************************************************************
+ *         make_internal_name
+ *
+ * Generate an internal name for an entry point. Used for stubs etc.
+ */
+static const char *make_internal_name( const ORDDEF *odp, DLLSPEC *spec, const char *prefix )
+{
+    static char buffer[256];
+    if (odp->name || odp->export_name)
+    {
+        char *p;
+        sprintf( buffer, "__wine_%s_%s_%s", prefix, spec->file_name,
+                 odp->name ? odp->name : odp->export_name );
+        /* make sure name is a legal C identifier */
+        for (p = buffer; *p; p++) if (!isalnum(*p) && *p != '_') break;
+        if (!*p) return buffer;
+    }
+    sprintf( buffer, "__wine_%s_%s_%d", prefix, make_c_identifier(spec->file_name), odp->ordinal );
+    return buffer;
+}
+
+
+/*******************************************************************
  *         output_relay_debug
  *
  * Output entry points for relay debugging
@@ -341,6 +363,44 @@
 
 
 /*******************************************************************
+ *         output_stub_funcs
+ *
+ * Output the functions for stub entry points
+ */
+static void output_stub_funcs( DLLSPEC *spec )
+{
+    int i;
+
+#if 0
+    for (i = 0; i < spec->nb_entry_points; i++)
+    {
+        ORDDEF *odp = &spec->entry_points[i];
+        if (odp->type != TYPE_STUB) continue;
+        fprintf( outfile, "#ifdef __GNUC__\n" );
+        fprintf( outfile, "extern void __wine_spec_unimplemented_stub( const char *module, const char *func ) __attribute__((noreturn));\n" );
+        fprintf( outfile, "#else\n" );
+        fprintf( outfile, "extern void __wine_spec_unimplemented_stub( const char *module, const char *func );\n" );
+        fprintf( outfile, "#endif\n\n" );
+        break;
+    }
+#endif
+
+    for (i = 0; i < spec->nb_entry_points; i++)
+    {
+        const ORDDEF *odp = &spec->entry_points[i];
+        if (odp->type != TYPE_STUB) continue;
+        output( "void %s(void) ", make_internal_name( odp, spec, "stub" ) );
+        if (odp->name)
+            output( "{ __wine_spec_unimplemented_stub(__wine_spec_file_name, \"%s\"); }\n", odp->name );
+        else if (odp->export_name)
+            output( "{ __wine_spec_unimplemented_stub(__wine_spec_file_name, \"%s\"); }\n", odp->export_name );
+        else
+            output( "{ __wine_spec_unimplemented_stub(__wine_spec_file_name, \"%d\"); }\n", odp->ordinal );
+    }
+}
+
+
+/*******************************************************************
  *         output_asm_constructor
  *
  * Output code for calling a dll constructor.
@@ -795,10 +855,6 @@
 
         if (!(odp->flags & FLAG_PRIVATE)) total++;
 
-        if (odp->type == TYPE_STUB) continue;
-
-        output( "  %s", name );
-
         switch(odp->type)
         {
         case TYPE_EXTERN:
@@ -807,12 +863,14 @@
         case TYPE_VARARGS:
         case TYPE_CDECL:
             /* try to reduce output */
+            output( "  %s", name );
             if(strcmp(name, odp->link_name) || (odp->flags & FLAG_FORWARD))
                 output( "=%s", odp->link_name );
             break;
         case TYPE_STDCALL:
         {
             int at_param = strlen(odp->u.func.arg_types) * get_ptr_size();
+            output( "  %s", name );
             if (!kill_at && target_cpu == CPU_x86) output( "@%d", at_param );
             if  (odp->flags & FLAG_FORWARD)
             {
@@ -825,6 +883,50 @@
             }
             break;
         }
+        case TYPE_FASTCALL:
+        {
+            int at_param = strlen(odp->u.func.arg_types) * get_ptr_size();
+            output( "  " );
+            if (!kill_at) output( "@" );
+            output( "%s", name );
+            if (!kill_at) output( "@%d", at_param );
+            if  (odp->flags & FLAG_FORWARD)
+            {
+                output( "=" );
+                output( "%s", odp->link_name );
+            }
+            else if (strcmp(name, odp->link_name)) /* try to reduce output */
+            {
+                output( "=" );
+                if (!kill_at) output( "@" );
+                output( "%s", odp->link_name );
+                if (!kill_at) output( "@%d", at_param );
+            }
+            break;
+        }
+        case TYPE_STUB:
+        {
+            output( "  %s", name );
+            if (!kill_at)
+            {
+                const char *check = name + strlen(name);
+                while (name != check &&
+                       '0' <= check[-1] && check[-1] <= '9')
+                {
+                    check--;
+                }
+                if (name != check && check != name + strlen(name) &&
+                    '@' == check[-1])
+                {
+                    output("%s", check - 1);
+                }
+            }
+            if (odp->name || odp->export_name)
+            {
+                output("=%s", make_internal_name( odp, spec, "stub" ));
+            }
+            break;
+        }
         default:
             assert(0);
         }
@@ -836,3 +939,52 @@
     }
     if (!total) warning( "%s: Import library doesn't export anything\n", spec->file_name );
 }
+
+
+/*******************************************************************
+ *         BuildPedllFile
+ *
+ * Build a PE DLL C file from a spec file.
+ */
+void BuildPedllFile( DLLSPEC *spec )
+{
+    int i, has_stubs = 0;
+
+    output_standard_file_header();
+
+    for (i = 0; i < spec->nb_entry_points; i++)
+    {
+        const ORDDEF *odp = &spec->entry_points[i];
+        if (odp->type == TYPE_STUB)
+        {
+            has_stubs = 1;
+            break;
+        }
+    }
+
+    if (!has_stubs)
+    {
+        output( "/* This file is intentionally left blank */\n");
+        return;
+    }
+
+    output( "#include <stdarg.h>\n");
+    output( "#include \"windef.h\"\n");
+    output( "#include \"winbase.h\"\n");
+    output( "#include \"wine/config.h\"\n");
+    output( "#include \"wine/exception.h\"\n\n");
+
+    output( "void __wine_spec_unimplemented_stub( const char *module, const char *function )\n");
+    output( "{\n");
+    output( "    ULONG_PTR args[2];\n");
+    output( "\n");
+    output( "    args[0] = (ULONG_PTR)module;\n");
+    output( "    args[1] = (ULONG_PTR)function;\n");
+    output( "    RaiseException( EXCEPTION_WINE_STUB, EH_NONCONTINUABLE, 2, args );\n");
+    output( "}\n\n");
+
+    output( "static const char __wine_spec_file_name[] = \"%s\";\n\n", spec->file_name );
+
+    /* Output the stub functions */
+    output_stub_funcs( spec );
+}
